#! /usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')

require 'lionel_richie'

Trello.configure do |c|
  c.developer_public_key = ENV['TRELLO_KEY']
  c.member_token = ENV['TRELLO_TOKEN']
end

board_id = ENV['TRELLO_BOARD_ID']
board = Trello::Board.find(board_id)

cards = []
board.lists.each do |list|
  list.cards.each do |card|
    cards << card
  end
end

session = GoogleDrive.login_with_oauth(ENV['GOOGLE_TOKEN'])

sp = session.spreadsheet_by_key(ENV['GOOGLE_DOC_ID'])
ws = sp.worksheets[0]

start_row = 2
rows = ws.rows.size

card_ids = cards.map(&:id)

def sync_row(ws, row, card)
  puts "syncing row[#{row}] with #{card.name}"
  ws["B#{row}"] = card.id

  # Card link
  ws["C#{row}"] = %Q[=HYPERLINK("#{card.url}", "#{card.name.gsub(/"/, "")}")]

  actions = card.actions
  actions = actions.select { |a| a.data["listBefore"].present? }

  # Ready date
  ws["D#{row}"] = action_date(actions) do |a|
    (a.type == "createCard" && a.data["board"]["id"] == board_id) ||
    a.data["listAfter"]["name"] =~ /ready/i
  end

  # In Progress date
  ws["E#{row}"] = action_date(actions) { |a| a.data["listAfter"]["name"] =~ /^in progress/i }

  # Code Review date
  ws["F#{row}"] = action_date(actions) { |a| a.data["listAfter"]["name"] =~ /^code review/i }

  # Review date
  ws["G#{row}"] = action_date(actions) { |a| a.data["listAfter"]["name"] =~ /^review/i }

  # Deploy date
  ws["H#{row}"] = action_date(actions) { |a| a.data["listAfter"]["name"] =~ /^deploy/i }

  # Completed date
  ws["I#{row}"] = action_date(actions) { |a| a.data["listAfter"]["name"] =~ /^completed/i }

  # Type
  labels = card.labels.map(&:name)
  type = labels.detect { |l| l.downcase =~ %r{bug|chore|task}i } || 'story'
  ws["J#{row}"] = type

  # Estimate
  match = card.name.match(/\[(?<estimate>\w)\]/)
  ws["L#{row}"] = match[:estimate] if match

rescue Trello::Error => e
  puts e.inspect
  puts card.inspect
end

def action_date(actions, &block)
  actions = actions.select(&block)
  return "" if actions.empty?
  action = actions.sort { |a, b| a.date <=> b.date }.first
  action.date.strftime("%m/%d/%Y")
end

card_rows = {}

# Find existing rows for current cards
(start_row..rows).each do |row|
  cell_id = ws["B#{row}"]
  next unless cell_id.present?
  card = cards.find { |c| c.id == cell_id }
  next unless card.present?
  card_rows[row] = card
end

# Set available rows for new cards
new_cards = cards - card_rows.values
new_cards.each_with_index do |card, i|
  row = rows + i + 1
  card_rows[row] = card
end

card_rows.each do |row, card|
  sleep 1
  Timeout.timeout(5) { sync_row(ws, row, card) }
end

ws.save

puts "exiting"
